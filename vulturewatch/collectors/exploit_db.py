"""Coletor de exploits do Exploit-DB"""
import requests
from bs4 import BeautifulSoup
from typing import List, Dict, Optional
import re
import logging
from ..security import validate_cve_id

logger = logging.getLogger(__name__)


class ExploitDBCollector:
    """Coleta informações de exploits do Exploit-DB"""
    
    BASE_URL = "https://www.exploit-db.com"
    SEARCH_URL = f"{BASE_URL}/search"
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
        })
    
    def search_exploits(self, cve_id: str) -> List[Dict]:
        """
        Busca exploits para um CVE específico
        
        Returns:
            Lista de exploits encontrados com informações de maturidade
        """
        # Valida CVE ID
        if not validate_cve_id(cve_id):
            logger.warning(f"CVE ID inválido: {cve_id}")
            return []
        
        exploits = []
        
        try:
            # Busca no Exploit-DB
            params = {"q": cve_id}
            response = self.session.get(self.SEARCH_URL, params=params, timeout=30)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Procura por links de exploits
            exploit_links = soup.find_all('a', href=re.compile(r'/exploits/\d+'))
            
            for link in exploit_links:
                exploit_id = re.search(r'/exploits/(\d+)', link.get('href', ''))
                if exploit_id:
                    exploit_url = f"{self.BASE_URL}{link.get('href')}"
                    
                    # Tenta extrair informações do exploit
                    exploit_info = self._get_exploit_details(exploit_id.group(1), exploit_url)
                    if exploit_info:
                        exploits.append(exploit_info)
            
            logger.debug(f"Encontrados {len(exploits)} exploits para {cve_id} no Exploit-DB")
            return exploits
        
        except requests.RequestException as e:
            logger.error(f"Erro ao buscar exploits do Exploit-DB para {cve_id}: {e}")
            return []
    
    def _get_exploit_details(self, exploit_id: str, exploit_url: str) -> Optional[Dict]:
        """Extrai detalhes de um exploit específico"""
        try:
            response = self.session.get(exploit_url, timeout=30)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Tenta determinar maturidade baseado no conteúdo
            maturity_level = self._assess_maturity(soup)
            
            return {
                "exploit_id": exploit_id,
                "url": exploit_url,
                "maturity_level": maturity_level,
                "source": "exploit_db"
            }
        
        except Exception as e:
            logger.debug(f"Erro ao obter detalhes do exploit {exploit_id}: {e}")
            return None
    
    def _assess_maturity(self, soup: BeautifulSoup) -> int:
        """
        Avalia maturidade do exploit baseado no conteúdo
        
        Returns:
            0-3: nível de maturidade
        """
        text = soup.get_text().lower()
        
        # Indicadores de maturidade alta (nível 3)
        if any(keyword in text for keyword in ["metasploit", "module", "exploit/multi", "msf"]):
            return 3
        
        # Indicadores de PoC funcional (nível 2)
        if any(keyword in text for keyword in ["python", "bash", "sh", "#!/bin", "#!/usr/bin", 
                                                "execute", "run", "usage:", "example:"]):
            return 2
        
        # Indicadores de PoC teórica (nível 1)
        if any(keyword in text for keyword in ["proof of concept", "poc", "concept", "theoretical"]):
            return 1
        
        # Caso padrão: apenas artigo/whitepaper (nível 0)
        return 0

